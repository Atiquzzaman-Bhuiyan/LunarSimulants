# -*- coding: utf-8 -*-
"""Drawing_polyline/polygone.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dyqyyCXZpzarwfTCgJu7c4SgrqTrJTAn
"""

import os
import cv2
import numpy as np
import xml.etree.ElementTree as ET
from google.colab.patches import cv2_imshow

from google.colab import drive
drive.mount('/content/drive')

xml_file_path = '/content/drive/My Drive/Amber Lab/CT DATA/Open Data/RA_annotations.xml'

class XMLParser:
    """A XML parser for loading annotated CT image."""
    def __init__(self, xml_path: str, labels: list[str]):
        """Initialize a XML parser.

        Args:
            xml_path: path to .xml file.
            labels: labels for parsing.
        """
        # Create annotation label map (label->idx)
        self.labels = {label: idx + 1 for idx, label in enumerate(sorted(labels))}  # Start from 1 to avoid using 0

        # Parse the .xml file to a tree
        tree = ET.parse(xml_path)
        root = tree.getroot()

        # Select the images from root
        self.images = [child for child in root if child.tag == "image"]
        self.images = sorted(self.images, key=lambda x: int(x.attrib['id']))

    def __len__(self) -> int:
        """Size of the annotated images."""
        return len(self.images)

    def __getitem__(self, idx: int) -> dict:
        """Annotation of the idx image."""
        return self._parse_image_annotation(self.images[idx])

    def _parse_image_annotation(self, root: ET.Element) -> dict:
        """Parse the polygons/polylines information based on its annotation.

        Args:
            root: an image root in the tree.

        Return:
            annotation: annotation dictionary of the image.
        """
        annotation = root.attrib.copy()
        annotation['records'] = []

        # Initialize segmentation mask
        H = int(annotation["height"])
        W = int(annotation["width"])
        canvas = np.zeros((H, W), dtype=np.uint8)

        for child in root:
            label = child.attrib['label']

            if label not in self.labels:
                continue

            record = {}
            if child.tag == "polygon" or child.tag == "polyline":
                record["type"] = child.tag
                record["label"] = self.labels[label]
                points = child.attrib["points"]
                points = np.array([[float(pt.split(',')[0]), float(pt.split(',')[1])] for pt in points.split(';')], dtype=np.int32)

                record["points"] = points
                annotation['records'].append(record)

                # Debug: Print points and labels
                print(f"Drawing {child.tag} with points: {points} and label: {record['label']}")

                # Check if points are within the image bounds
                if np.any(points < 0) or np.any(points[:, 0] >= W) or np.any(points[:, 1] >= H):
                    print("Warning: Some points are out of image bounds")

                # Use cv2.fillPoly and cv2.polylines with debug colors
                color = record["label"] * 100 # Multiplying to get distinct values for visualization
                if child.tag == "polygon":
                    cv2.fillPoly(canvas, [points], color=color)
                elif child.tag == "polyline":
                    cv2.polylines(canvas, [points], isClosed=False, color=color, thickness=1)

                #  Show the intermediate canvas
                cv2_imshow(canvas)
                cv2.waitKey(0)  # Wait for a key press to proceed to the next shape

            else:
                continue

        annotation["mask"] = canvas
        return annotation

CT_LABEL = ["crack", "pore"]
XML_PATH = xml_file_path    # Change xml_path as needed

parser = XMLParser(XML_PATH, CT_LABEL)
print(f"{XML_PATH} has {len(parser)} annotated images.")
idx = 12
annotation = parser[idx]

# Display the annotation mask
cv2_imshow(annotation['mask'])
cv2.waitKey(0)  # Wait for a key press before closing the image window

idx = 0
annotation = parser[idx]

# Display the annotation mask
cv2_imshow(annotation['mask'])
cv2.waitKey(0)  # Wait for a key press before closing the image window

for idx in range(len(parser)):
    annotation = parser[idx]
    print(f"Displaying mask for image index: {idx}")
    cv2_imshow(annotation['mask'])
    cv2.waitKey(0)